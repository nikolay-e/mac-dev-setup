name: "mac-dev-setup"
type: directory
children:
  - name: ".editorconfig"
    type: file
    content: |
      # EditorConfig helps maintain consistent coding styles for multiple developers
      # working on the same project across various editors and IDEs.
      # editorconfig.org

      root = true

      [*]
      end_of_line = lf
      insert_final_newline = true
      charset = utf-8
      trim_trailing_whitespace = true
      indent_style = space
      indent_size = 2

      [*.md]
      trim_trailing_whitespace = false
  - name: ".github"
    type: directory
    children:
    - name: "CODEOWNERS"
      type: file
      content: |
        # Auto‑request reviews on PRs touching critical files
        Brewfile           @nikolay-e
        install.sh         @nikolay-e
        .github/workflows/ @nikolay-e
    - name: "ISSUE_TEMPLATE"
      type: directory
      children:
      - name: "bug.yml"
        type: file
        content: |
          name: Bug Report
          description: Something isn't working in mac-dev-setup
          labels: ["bug"]
          body:
            - type: textarea
              attributes:
                label: What happened?
                description: Tell us what you were doing and what went wrong.
            - type: textarea
              attributes:
                label: Steps to reproduce
                placeholder: |
                  1. …
                  2. …
            - type: input
              attributes:
                label: macOS version
                placeholder: e.g. 14.4 (Sonoma)
            - type: textarea
              attributes:
                label: Terminal output
                description: Please paste any error messages or relevant output
                render: shell
    - name: "PULL_REQUEST_TEMPLATE.md"
      type: file
      content: |
        ## What & Why
        <!-- bullet‑point summary -->

        ## Testing
        - [ ] Ran `./install.sh` on macOS
        - [ ] `brew bundle --dry-run` passes
        - [ ] All scripts pass ShellCheck

        ## Checklist
        - [ ] I've updated docs if needed
        - [ ] I've added or adjusted tests
        - [ ] Scripts are executable (`chmod +x`)
    - name: "dependabot.yml"
      type: file
      content: |
        version: 2
        updates:
          # GitHub Actions dependencies
          - package-ecosystem: "github-actions"
            directory: "/"
            schedule:
              interval: "weekly"
              day: "monday"
              time: "09:00"
            open-pull-requests-limit: 10
            reviewers:
              - "nikolay-e"
            commit-message:
              prefix: "chore"
              include: "scope"

          # NPM dependencies (shell plugins as Git dependencies only)
          - package-ecosystem: "npm"
            directory: "/"
            schedule:
              interval: "weekly"
              day: "monday"
              time: "09:00"
            open-pull-requests-limit: 5
            reviewers:
              - "nikolay-e"
            commit-message:
              prefix: "chore"
              include: "scope"

          # Python dependencies
          - package-ecosystem: "pip"
            directory: "/"
            schedule:
              interval: "weekly"
              day: "monday"
              time: "09:00"
            open-pull-requests-limit: 5
            reviewers:
              - "nikolay-e"
            commit-message:
              prefix: "chore"
              include: "scope"
    - name: "workflows"
      type: directory
      children:
      - name: "bats-tests.yml"
        type: file
        content: |
          name: BATS

          on: [push, pull_request]

          jobs:
            bats:
              strategy:
                matrix:
                  os: [macos-latest, macos-13]
              runs-on: ${{ matrix.os }}
              steps:
                - uses: actions/checkout@v4
                - uses: mig4/setup-bats@v1
                - name: Run tests
                  run: |
                    bats test
      - name: "brew-bundle-test.yml"
        type: file
        content: |
          name: Brew Bundle (dry-run)

          on:
            pull_request:
              paths: ["Brewfile"]

          jobs:
            brewfile:
              runs-on: macos-latest
              steps:
                - uses: actions/checkout@v4
                - name: Dry-run Brew Bundle
                  run: |
                    brew update
                    brew bundle --file=./Brewfile --no-lock --verbose --dry-run
      - name: "install-test.yml"
        type: file
        content: |
          name: Install Tests

          on:
            pull_request:
            push:

          jobs:
            install-dry-run:
              name: Install (dry-run)
              runs-on: macos-latest
              steps:
                - uses: actions/checkout@v4
                - name: Dry-run installer
                  run: |
                    chmod +x install.sh
                    ./install.sh -n   # -n == dry-run

            install-full:
              name: Install (full)
              runs-on: macos-latest
              steps:
                - uses: actions/checkout@v4
                - name: Full install test
                  run: |
                    chmod +x install.sh
                    ./install.sh
                - name: Verify installation
                  run: |
                    # Check if key tools were installed
                    command -v eza || echo "❌ eza not found"
                    command -v bat || echo "❌ bat not found"
                    command -v fd || echo "❌ fd not found"
                    command -v rg || echo "❌ rg not found"
                    command -v jq || echo "❌ jq not found"

                    # Check if aliases file was created
                    [ -f ~/.mac-dev-setup-aliases ] || echo "❌ aliases file not found"

                    # Check if zsh config was created
                    [ -f ~/.zsh_config.sh ] || echo "❌ zsh config not found"

                    # Verify alias file contains expected aliases (without sourcing)
                    grep -q "alias gs=" ~/.mac-dev-setup-aliases || echo "❌ gs alias not found in file"
                    grep -q "alias k=" ~/.mac-dev-setup-aliases || echo "❌ k alias not found in file"
      - name: "shellcheck.yml"
        type: file
        content: |
          name: Shell Lint

          on:
            push:
              paths: ["*.sh", "**/*.sh", ".github/workflows/shellcheck.yml"]
            pull_request:
              paths: ["*.sh", "**/*.sh"]

          jobs:
            shellcheck:
              runs-on: ubuntu-latest
              steps:
                - uses: actions/checkout@v4
                - name: Verify chmod
                  run: |
                    test -x install.sh && test -x uninstall.sh
                - uses: ludeeus/action-shellcheck@2.0.0
                  with:
                    severity: warning
      - name: "test.yml"
        type: file
        content: |
          name: Test Installation

          on:
            push:
              branches: [ main ]
            pull_request:
              branches: [ main ]

          jobs:
            test:
              runs-on: macos-latest

              steps:
              - uses: actions/checkout@v4

              - name: Test installation (simulate user input)
                run: echo "n" | ./install.sh || echo "Installation cancelled as expected"

              - name: Test brew task directly
                run: bash tasks/brew.install.sh --print

              - name: Test python task directly
                run: bash tasks/python.install.sh --print

              - name: Verify config files exist
                run: |
                  test -f "Brewfile"
                  test -f "pipx.txt"
                  echo "✅ Config files found"

              - name: Test Brewfile syntax
                run: |
                  ruby -c Brewfile
                  echo "✅ Brewfile syntax valid"
  - name: ".gitignore"
    type: file
    content: |
      # macOS System Files
      .DS_Store
      .AppleDouble
      .LSOverride
      ._*
      .Spotlight-V100
      .Trashes
      Thumbs.db
      __MACOSX

      # Backup directories
      .dotfiles_backup/
      backup/

      # Editor & IDE directories
      .vscode/
      .idea/
      *.sublime-*

      # Shell history and temporary files
      *.swp
      *.swo
      *.tmp
      *.log
      .bash_history
      .zsh_history

      # Python development artifacts
      __pycache__/
      *.pyc
      *.pyo
      *.pyd
      .Python
      build/
      develop-eggs/
      dist/
      downloads/
      eggs/
      .eggs/
      lib/
      lib64/
      parts/
      sdist/
      var/
      wheels/
      *.egg-info/
      .installed.cfg
      *.egg
      .pytest_cache/

      # learn-aliases build artifacts
      learn-aliases/build/
      learn-aliases/*.egg-info/

      # Homebrew lock files (we use static Brewfile)
      Brewfile.lock.json

      # Test outputs
      test_output/
      coverage/
      .coverage

      # Local environment overrides
      .env
      .env.local
  - name: ".mac-dev-setup-aliases"
    type: file
    content: |
      #!/bin/bash
      # shellcheck shell=bash
      # --------------------------------------------------------------------
      ## Modern CLI Replacements & Aliases
      # --------------------------------------------------------------------
      # Use modern alternatives for core commands
      alias cat='bat --paging=never' # Modern file viewer with syntax highlighting for code files

      # File listing with modern tool (colorized output with icons and git status)
      alias ls='eza'                      # Basic file listing with colors and icons
      alias l='eza -1'                     # Quick file listing
      alias ll='eza -l'                   # Detailed view: permissions, size, date, owner
      alias la='eza -la'                  # Show all files including hidden ones starting with dot
      alias lt='eza -T --level=2'         # Tree view of directory structure (2 levels deep)
      alias l.='eza -la | grep "^\."'     # Show only dotfiles (.bashrc, .gitconfig, etc)
      alias ltr='eza -la --sort=modified' # Sort by modification time (newest first)
      alias lsd='eza -la | grep "^d"'     # Show only directories (folders)
      alias lss='eza -la --sort=size'     # Sort by file size (largest first)

      # --------------------------------------------------------------------
      ## Navigation & Zsh
      # --------------------------------------------------------------------
      alias ..='cd ..'                                                  # Navigate up one directory level
      alias ...='cd ../..'                                              # Navigate up two directory levels
      alias ....='cd ../../..'                                          # Navigate up three directory levels
      alias .....='cd ../../../..'                                      # Navigate up four directory levels
      alias ......='cd ../../../../..'                                  # Navigate up five directory levels
      alias cd..='cd ..'                                                # Fix common typing mistake (missing space)
      alias ~='cd ~'                                                    # Jump to home directory quickly
      alias icloud='cd ~/Library/Mobile\ Documents/com~apple~CloudDocs' # Jump to iCloud Drive folder
      alias ccode='cd ~/code'                                           # Jump to main coding projects folder
      alias dev='cd ~/Development'                                      # Jump to development projects folder
      alias dl='cd ~/Downloads'                                         # Jump to downloads folder
      alias zshconfig='nvim ~/.zshrc'                                   # Edit shell configuration file
      alias zshrc='nvim ~/.zshrc && source ~/.zshrc'                    # Edit config file and apply changes immediately
      alias reload='source ~/.zshrc'                                    # Apply shell config changes without restarting terminal
      alias hosts='sudo nvim /etc/hosts'                                # Edit system hosts file (requires admin password)

      # --------------------------------------------------------------------
      ## Tree & Clipboard
      # --------------------------------------------------------------------
      alias tree='tree -C'                                      # Show directory structure as a visual tree with colors
      alias treex='tree -C -I "node_modules|*.pyc|__pycache__"' # Clean tree view without build artifacts
      alias c='clear'                                           # Clear terminal screen (clean slate)
      alias p='pbpaste'                                         # Paste text from system clipboard to terminal
      alias copypwd='pwd | pbcopy'                              # Copy current directory path to clipboard

      # --------------------------------------------------------------------
      ## Neovim (nvim)
      # --------------------------------------------------------------------
      alias v='nvim'              # Launch modern text editor
      alias vi='nvim'             # Classic editor command with modern features
      alias vim='nvim'            # Enhanced version of traditional editor
      alias e='nvim'              # Quick editor launcher
      alias oldvim='/usr/bin/vim' # Original system editor (fallback)

      # --------------------------------------------------------------------
      ## Git
      # --------------------------------------------------------------------
      alias g='git'                                           # Version control system command shortcut
      alias gs='git status'                                # Quick overview of file changes (compact format)
      alias ga='git add'                                      # Stage specific files for next commit
      alias gaa='git add --all'                               # Stage all changed files for commit
      alias gcm='git commit -m'                                # Save changes with descriptive message
      alias gca='git commit --amend --no-edit'                # Fix last commit without changing message
      alias gb='git branch'                                   # List existing branches or create new ones
      alias gc='git checkout'                                # Switch between branches or restore files
      alias gcb='git checkout -b'                             # Create new branch and switch to it
      alias gp='git push'                                     # Upload local commits to remote repository
      alias gpf='git push --force-with-lease'                 # Force upload with safety check
      alias gpom='git push origin main'                       # Upload to main branch
      alias gpod='git push origin develop'                    # Upload to development branch
      alias gl='git pull'                                     # Download latest changes from remote
      alias glog='git log --oneline --decorate --graph --all' # Visual commit history with branches
      alias gd='git diff'                                     # Show what changed in files (not staged)
      alias gdc='git diff --cached'                           # Show what's staged for next commit
      alias gba='git branch -a'                               # List all branches including remote ones
      alias gcam='git commit -a -m'                           # Stage and commit all tracked changes at once
      alias gcaa='git commit -a --amend --no-edit'
      alias glg='git log --graph --pretty=format:"%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset" --abbrev-commit' # Beautiful commit history with colors and graph
      alias gsync='git fetch origin && git rebase origin/$(git rev-parse --abbrev-ref HEAD)'                                                      # Update branch with latest remote changes
      alias gfix='git commit --fixup'                                                                                                             # Create commit to fix earlier commit (for squashing)
      alias gsquash='git rebase -i --autosquash'                                                                                                  # Combine multiple commits into cleaner history
      alias gstash='git stash push -m'                                                                                                            # Temporarily save changes with description
      alias gsh='git stash'                                                                                                                       # Quick temporary save of current changes
      alias gsp='git stash pop'                                                                                                                   # Restore and remove most recent temporary save
      alias gwip='git add -A && git commit -m "WIP" --no-verify'         # Quick save work in progress (skip hooks)
      alias gunwip='git log -n 1 | grep -q -c "WIP" && git reset HEAD~1' # Undo work-in-progress save
      alias gundo='git reset --soft HEAD~1'                              # Undo last commit but keep changes ready
      alias gundo-hard='git reset --hard HEAD~1'                         # Undo last commit and destroy all changes

      gclean() {
        echo "  DANGER: This will DELETE all uncommitted changes and untracked files!"
        echo "Press Ctrl+C to cancel, or Enter to continue..."
        read -r
        git reset --hard && git clean -dffx
        git branch --merged | grep -v "\\*\\|main\\|master" | xargs -n 1 git branch -d
      }

      # GitHub CLI shortcuts
      # GitHub CLI aliases removed - tool not included in secure environment

      # --------------------------------------------------------------------
      ## Kubernetes (Enhanced with ahmetb-style aliases)
      # --------------------------------------------------------------------
      alias k='kubectl'      # Container orchestration system command
      alias kg='kubectl get' # Retrieve information about cluster resources

      # Get commands (retrieve cluster information)
      alias kgp='kubectl get pods'                 # List running application containers
      alias kgpo='kubectl get pods -o wide'        # List containers with node placement info
      alias kgpw='kubectl get pods --watch'        # Monitor container status changes in real-time
      alias kgs='kubectl get services'             # List network endpoints for applications
      alias kgso='kubectl get services -o wide'    # List network services with IP details
      alias kgd='kubectl get deployments'          # List application deployment configurations
      alias kgdo='kubectl get deployments -o wide' # List deployments with replica details
      alias kgn='kubectl get nodes'                # List cluster worker machines
      alias kgno='kubectl get nodes -o wide'       # List worker machines with system info
      alias kgns='kubectl get namespaces'          # List isolated environments in cluster
      alias kgcm='kubectl get configmaps'          # List configuration data storage objects
      alias kgsec='kubectl get secrets'            # List encrypted credential storage objects
      alias kgall='kubectl get all'                # List all major resources in current namespace

      # Describe commands (detailed information)
      alias kdp='kubectl describe pod'        # Get detailed container information and events
      alias kds='kubectl describe service'    # Get detailed network service configuration
      alias kdd='kubectl describe deployment' # Get detailed application deployment info
      alias kdn='kubectl describe node'       # Get detailed worker machine information

      # Logs and exec (debugging and monitoring)
      alias kl='kubectl logs'                 # View application output and error messages
      alias klf='kubectl logs -f'             # Stream live application logs
      alias klt='kubectl logs --tail=100'     # View last 100 lines of application output
      alias klft='kubectl logs -f --tail=100' # Stream last 100 lines and continue
      alias kexec='kubectl exec -it'          # Connect to running container for debugging

      # Apply and delete (resource management)
      alias kapp='kubectl apply -f'           # Deploy configuration from YAML file
      alias kdel='kubectl delete'             # Remove resources from cluster
      alias kdelp='kubectl delete pod'        # Remove specific application container
      alias kdels='kubectl delete service'    # Remove network service endpoint
      alias kdeld='kubectl delete deployment' # Remove application deployment

      # Port forwarding and proxy (network access)
      alias kpf='kubectl port-forward' # Access cluster applications locally (Usage: kpf svc/myapp 8080:80)
      alias kproxy='kubectl proxy'     # Create local gateway to cluster API

      # Context and namespace management (cluster switching)
      alias kctx='kubectx'                       # Switch between different clusters
      alias kns='kubens'                         # Switch between isolated environments
      alias kgc='kubectl config get-contexts'    # List all available clusters
      alias kcc='kubectl config current-context' # Show which cluster you're connected to

      # Quick utilities
      kdebug() {
        kubectl run "debug-$(date +%s)" --rm -i --tty --image=nicolaka/netshoot -- sh
      }

      kdebug-simple() {
        kubectl run "debug-$(date +%s)" --rm -i --tty --image=busybox -- sh
      }

      kclean() {
        kubectl get pods --field-selector=status.phase=Succeeded -o name | xargs -r kubectl delete
      }

      # Advanced debugging with kubectl plugins (requires krew)
      ktree() {
        kubectl tree "${1:-deployment}" "${2}"
      }

      kneat() {
        kubectl neat get "${1}" "${2}" -o yaml
      }

      kaccess() {
        kubectl access-matrix --sa "${1:-default}"
      }

      # Resource analysis
      ktop-cpu() {
        kubectl top pod --all-namespaces --sort-by=cpu
      }

      ktop-mem() {
        kubectl top pod --all-namespaces --sort-by=memory
      }

      # Helm (Kubernetes Package Manager)
      alias h='helm'                    # Base Helm command
      alias hi='helm install'           # Install a chart
      alias hu='helm upgrade --install' # Upgrade or install chart
      alias hl='helm list'              # List releases
      alias hd='helm delete'            # Delete a release
      alias hs='helm search repo'       # Search for charts in repos
      alias hr='helm repo add'          # Add a chart repository
      alias hru='helm repo update'      # Update repo cache

      # Helm function for quick status
      helm-status() {
        if [ -z "$1" ]; then
          echo "Usage: helm-status <release_name>"
          return 1
        fi
        helm status "$1" --output table
      }

      # --------------------------------------------------------------------
      ## Docker & Container Management
      # --------------------------------------------------------------------
      alias d='docker'                      # Container platform command
      alias dc='docker compose'             # Multi-container application orchestrator
      alias dps='docker ps'                 # List currently running isolated environments
      alias dpsa='docker ps -a'             # List all environments (running and stopped)
      alias di='docker images'              # List available application templates
      alias drm='docker rm'                 # Remove stopped container environments
      alias drmi='docker rmi'               # Remove application template images
      alias db='docker build'               # Create application template from instructions
      alias dr='docker run -it --rm'        # Start temporary interactive container session
      alias dexec='docker exec -it'         # Connect to running container for debugging
      alias dlogs='docker logs -f'          # Stream application output from container
      alias dcu='docker compose up -d'      # Start multi-service application in background
      alias dcd='docker compose down'       # Stop and cleanup multi-service application
      alias dprune='docker system prune -f' # Clean up unused containers and images

      # Enhanced Docker functions
      docker-clean() {
        echo "  Cleaning up Docker resources..."
        docker system prune -f --volumes # Remove unused images, containers, networks, volumes
        docker volume prune -f           # Prune dangling volumes
      }

      docker-bash() {
        if [ -z "$1" ]; then
          echo "Usage: docker-bash <container_id_or_name>"
          return 1
        fi
        docker exec -it "$1" /bin/bash || docker exec -it "$1" /bin/sh # Open shell in running container for debugging
      }

      docker-stats() {
        docker stats --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}\t{{.BlockIO}}" # Monitor container resource usage
      }

      # --------------------------------------------------------------------
      ## Terraform & Infrastructure as Code
      # --------------------------------------------------------------------
      alias tf='terraform'                 # Infrastructure provisioning tool
      alias tfi='terraform init'           # Initialize project and download provider plugins
      alias tfp='terraform plan'           # Preview infrastructure changes before applying
      alias tfa='terraform apply'          # Create or update cloud infrastructure
      alias tfd='terraform destroy'        # Delete all managed cloud resources
      alias tfv='terraform validate'       # Check configuration syntax and logic
      alias tff='terraform fmt -recursive' # Format code for consistent style
      alias tfs='terraform show'           # Display current infrastructure state
      alias tfr='terraform refresh'        # Update state with real infrastructure
      alias tfo='terraform output'         # Display infrastructure output values
      alias tfws='terraform workspace'     # Manage isolated infrastructure environments

      # Modern Terraform workflow functions (using tenv for version management)
      tfapply() {
        terraform plan -out=tfplan && terraform apply tfplan
      }

      tfplan() {
        terraform plan -out=tfplan "$@"
      }

      tfdestroy-safe() {
        terraform plan -destroy -out=destroy.plan &&
          read -p "Execute destroy plan? (y/N) " -n 1 -r &&
          echo &&
          if [[ $REPLY =~ ^[Yy]$ ]]; then
            terraform apply "destroy.plan"
          fi
      }

      # Enhanced Terraform workflows
      tfwswitch() {
        terraform workspace select "$1" && terraform plan -var-file="workspaces/$1.tfvars"
      }

      tfsec() {
        # trivy removed - tool not included in secure environment
        echo "trivy not available in secure environment"
      }

      tfcost() {
        # infracost removed - tool not included in secure environment
        echo "infracost not available in secure environment"
      }

      tfdocs() {
        terraform-docs markdown table . >README.md
        echo "Documentation generated in README.md"
      }

      # Version management with tenv (replaces tfenv)
      alias tfuse='tenv use terraform'
      alias tflist='tenv list terraform'
      alias tfinstall='tenv install terraform'

      # --------------------------------------------------------------------
      ## AWS CLI
      # --------------------------------------------------------------------
      alias aw='aws'                                                                                                                                                  # Amazon Web Services cloud platform command
      alias awls='aws ec2 describe-instances --query "Reservations[*].Instances[*].[InstanceId,State.Name,InstanceType,Tags[?Key==`Name`].Value|[0]]" --output table' # List cloud virtual machines in table format
      alias awstop='aws ec2 stop-instances --instance-ids'                                                                                                            # Shutdown cloud virtual machines
      alias awstart='aws ec2 start-instances --instance-ids'                                                                                                          # Power on cloud virtual machines
      alias aws3ls='aws s3 ls'                                                                                                                                        # List cloud storage buckets
      alias aws3cp='aws s3 cp'                                                                                                                                        # Transfer files to/from cloud storage
      alias awlambda='aws lambda list-functions --query "Functions[*].[FunctionName,Runtime]" --output table'                                                         # List serverless function deployments
      alias awlogin='aws sso login'                                                                                                                                   # Authenticate with single sign-on
      alias awprofile='export AWS_PROFILE='                                                                                                                           # Switch between cloud account configurations

      # AWS functions for common tasks
      aws-ec2-ip() {
        if [ -z "$1" ]; then
          echo "Usage: aws-ec2-ip <instance_id>"
          return 1
        fi
        aws ec2 describe-instances --instance-ids "$1" --query "Reservations[*].Instances[*].PublicIpAddress" --output text # Get public IP of virtual machine
      }

      aws-s3-size() {
        if [ -z "$1" ]; then
          echo "Usage: aws-s3-size <bucket_name>"
          return 1
        fi
        aws s3 ls --summarize --human-readable --recursive "s3://$1" | tail -1 # Calculate total storage bucket size
      }

      # --------------------------------------------------------------------
      ## Homebrew (macOS Package Management)
      # --------------------------------------------------------------------
      alias brew-update='brew update && brew upgrade && brew cleanup' # Update all macOS software packages
      alias bru='brew update && brew upgrade'                         # Quick system software update
      alias bri='brew install'                                        # Install new software package
      alias brs='brew search'                                         # Find available software packages
      alias brl='brew list'                                           # Show installed software packages
      alias brr='brew remove'                                         # Uninstall software package
      alias brc='brew cleanup'                                        # Remove old software versions to save space

      # --------------------------------------------------------------------
      ## NPM & Yarn (Node.js Package Management)
      # --------------------------------------------------------------------
      alias ni='npm install'     # Install JavaScript/Node.js project dependencies
      alias nid='npm install -D' # Install development-only dependencies
      alias nr='npm run'         # Execute project scripts (build, test, start)
      alias nt='npm test'        # Run automated test suite
      alias ns='npm start'       # Launch application in development mode
      alias nb='npm run build'   # Compile application for production
      alias yi='yarn install'    # Install dependencies using alternative package manager
      alias ya='yarn add'        # Add new dependency to project
      alias yr='yarn run'        # Execute project scripts with yarn
      alias ys='yarn start'      # Launch application using yarn
      alias yt='yarn test'       # Run tests using yarn

      # Function to detect and use the right package manager
      pm-run() {
        if [ -f "yarn.lock" ]; then
          yarn "$@"
        elif [ -f "package-lock.json" ]; then
          npm run "$@"
        else
          echo "No lockfile found; defaulting to npm run"
          npm run "$@"
        fi
      }

      # --------------------------------------------------------------------
      ## Productivity
      # --------------------------------------------------------------------
      # Quick navigation with zoxide (after it's installed, use 'z' to jump to directories)
      alias zz='z -' # Go back to previous directory
      alias zi='zi'  # Interactive directory selection

      # Quick file operations
      alias mkd='mkdir -p' # Create directory and any missing parent directories

      # Make directory and change into it (80% of dotfiles have this)
      mcd() {
        mkdir -p "$1" && cd "$1" || return # Create directory and navigate to it in one command
      }

      # Quick backup function
      backup() {
        cp "$1"{,.bak} # Create backup copy with .bak extension
      }
      alias duh='du -h -d 1 | sort -h' # Show folder sizes in current directory (sorted)
      alias df='df -h'                 # Show disk space usage in readable format
      alias hist='history'             # Show previously executed commands
      alias j='jobs -l'                # List running background processes

      # Process management
      alias psg='ps aux | grep -v grep | grep -i' # Find running programs by name
      alias psmem='ps auxf | sort -nr -k 4'       # List programs sorted by memory usage
      alias pscpu='ps auxf | sort -nr -k 3'       # List programs sorted by CPU usage
      killport() {
        if [ -z "$1" ]; then
          echo "Usage: killport <port_number>"
          return 1
        fi
        lsof -ti:"$1" | xargs kill -9 # Force stop program using specific network port
      }

      # Archive extraction helper
      extract() {
        if [ -f "$1" ]; then
          case "$1" in
            *.tar.bz2) tar xjf "$1" ;;
            *.tar.gz) tar xzf "$1" ;;
            *.bz2) bunzip2 "$1" ;;
            *.rar) unrar x "$1" ;;
            *.gz) gunzip "$1" ;;
            *.tar) tar xf "$1" ;;
            *.tbz2) tar xjf "$1" ;;
            *.tgz) tar xzf "$1" ;;
            *.zip) unzip "$1" ;;
            *.Z) uncompress "$1" ;;
            *.7z) 7z x "$1" ;;
            *) echo "'$1' cannot be extracted via extract()" ;;
          esac
        else
          echo "'$1' is not a valid file"
        fi # Universal archive extractor - handles zip, tar, rar, 7z, etc.
      }

      # --------------------------------------------------------------------
      ## Utilities
      # --------------------------------------------------------------------
      # myip removed - uses curl to external service
      alias localip='ipconfig getifaddr en0'                                         # Show your local network IP address
      alias serve='python3 -m http.server'                                           # Start local web server for current folder
      alias flushdns='sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder' # Clear DNS cache to fix network issues
      alias zj='zellij'                                                              # Launch terminal multiplexer (multiple terminal sessions)
      # weather removed - uses curl to external service
      alias copykey='pbcopy < ~/.ssh/id_rsa.pub'                                     # Copy SSH public key for server access
      alias copykey-ed='pbcopy < ~/.ssh/id_ed25519.pub'                              # Copy modern SSH key for secure connections

      # Modern shell automation with jc (CLI to JSON conversion)
      alias psj='ps aux | jc --ps'       # Convert process list to structured JSON data
      alias lsj='eza -la | jc --ls'      # Convert file listing to structured JSON data
      alias dfj='df -h | jc --df'        # Convert disk usage to structured JSON data
      alias digj='dig +short | jc --dig' # Convert DNS lookup to structured JSON data

      # JSON processing with jq (colorized output)
      alias jq='jq -C'  # Pretty-print JSON with colors for readability
      alias jqs='jq -S' # Sort JSON object keys alphabetically

      # Quick epoch time converter
      epoch() {
        if [ $# -eq 0 ]; then
          date +%s # Current epoch
        else
          date -r "$1" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date -d @"$1" '+%Y-%m-%d %H:%M:%S' # Convert epoch to readable (macOS/Linux compatible)
        fi
      }

      # Git hooks and quality gates
      alias precommit='pre-commit run --all-files' # Run code quality checks before committing

      # --------------------------------------------------------------------
      ## Data Streaming & Kafka
      # --------------------------------------------------------------------
      # kcat (Kafka CLI) - requires KAFKA_BROKERS environment variable
      # Usage: export KAFKA_BROKERS="broker1:9092,broker2:9092"

      # Safe Kafka aliases with environment checks
      kcatp() {
        if [[ -z "$KAFKA_BROKERS" ]]; then
          echo " Error: Set KAFKA_BROKERS environment variable first"
          echo "Example: export KAFKA_BROKERS='localhost:9092'"
          return 1
        fi
        kcat -P -b "$KAFKA_BROKERS" -t "$@" # Send messages to data streaming topic
      }

      kcatc() {
        if [[ -z "$KAFKA_BROKERS" ]]; then
          echo " Error: Set KAFKA_BROKERS environment variable first"
          echo "Example: export KAFKA_BROKERS='localhost:9092'"
          return 1
        fi
        kcat -C -b "$KAFKA_BROKERS" -t "$@" # Read messages from data streaming topic
      }

      kcatl() {
        if [[ -z "$KAFKA_BROKERS" ]]; then
          echo " Error: Set KAFKA_BROKERS environment variable first"
          echo "Example: export KAFKA_BROKERS='localhost:9092'"
          return 1
        fi
        kcat -L -b "$KAFKA_BROKERS" "$@" # List available streaming topics and partitions
      }

      # Kafka topic helpers
      kcat-tail() {
        if [ -z "$1" ]; then
          echo "Usage: kcat-tail <topic> [partition]"
          return 1
        fi
        kcat -C -b "$KAFKA_BROKERS" -t "$1" -o -10 "$@" # Show last 10 messages from streaming topic
      }

      kcat-produce-json() {
        if [ -z "$1" ]; then
          echo "Usage: kcat-produce-json <topic>"
          echo "Then input JSON messages (Ctrl+D to end)"
          return 1
        fi
        kcat -P -b "$KAFKA_BROKERS" -t "$1" -T # Send JSON messages to streaming topic interactively
      }
  - name: ".pre-commit-config.yaml"
    type: file
    content: |
      # Pre-commit hooks configuration
      repos:
        - repo: https://github.com/pre-commit/pre-commit-hooks
          rev: v5.0.0
          hooks:
            - id: trailing-whitespace
            - id: end-of-file-fixer
            - id: check-yaml
            - id: check-json
            - id: check-added-large-files
            - id: check-merge-conflict
            - id: check-shebang-scripts-are-executable

        - repo: https://github.com/koalaman/shellcheck-precommit
          rev: v0.10.0
          hooks:
            - id: shellcheck
              args: ["--severity=warning"]

        - repo: https://github.com/scop/pre-commit-shfmt
          rev: v3.8.0-1
          hooks:
            - id: shfmt
              args: ["-i", "2", "-ci"]
  - name: "Brewfile"
    type: file
    content: |
      # Brewfile - Static configuration for secure development environment
      # All tools are vetted for security and offline capability

      # Core CLI tools
      brew "git"
      brew "jq"
      brew "jc"
      brew "tree"
      brew "fzf"
      brew "shfmt"

      # Modern CLI replacements
      brew "neovim"
      brew "ripgrep"
      brew "bat"
      brew "eza"
      brew "fd"
      brew "zoxide"

      # Terminal tools
      brew "zellij"

      # Development tools
      brew "pyenv"
      brew "pipx"
      brew "nvm"
      brew "mise"

      # Container & Infrastructure (user-directed network only)
      brew "docker"
      brew "kubectl"
      brew "helm"
      brew "terraform"
      brew "terragrunt"

      # Essential tools
      brew "wget"
      brew "htop"
  - name: "CONTRIBUTING.md"
    type: file
    content: |
      # Contributing to mac-dev-setup

      Thank you for your interest in contributing! This project aims to be a robust, well-tested setup for macOS development environments.

      ## Getting Started

      1. Fork the repository
      2. Create a feature branch: `git checkout -b feature/your-feature`
      3. Make your changes
      4. Test your changes (see Testing section)
      5. Submit a pull request

      ## Testing

      Before submitting changes:

      ```bash
      # Run shell linting
      shellcheck *.sh

      # Run tests
      bats test/

      # Test Brewfile
      brew bundle --dry-run

      # Test install script (in a safe environment)
      ./install.sh
      ```

      ## Code Standards

      - Use `set -euo pipefail` in all shell scripts
      - Follow existing code style and naming conventions
      - Add comments for complex logic
      - Update documentation for user-facing changes

      ## What to Contribute

      - **Bug fixes**: Always welcome
      - **New tools**: Add to Brewfile with clear rationale
      - **Improvements**: Better error handling, performance, etc.
      - **Documentation**: Help make setup clearer

      ## Questions?

      Open an issue for discussion before major changes.
  - name: "LICENSE"
    type: file
    content: |
      MIT License

      Copyright (c) 2024 Nikolay E

      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:

      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
  - name: "README.md"
    type: file
    content: |
      # mac-dev-setup 🚀

      **Secure, offline-first macOS development environment with vetted tools and no telemetry.**

      ## Quick Start

      ```bash
      git clone https://github.com/nikolay-e/mac-dev-setup.git
      cd mac-dev-setup
      ./install.sh
      ```

      ## What's Included

      All tools are carefully vetted for security and work completely offline:

      ### Core Development Tools
      - **Git ecosystem**: `git`, modern diffs, terminal workflows
      - **Modern CLI**: `eza` (ls), `bat` (cat), `fd` (find), `rg` (grep), `zoxide` (cd)
      - **Editors & Terminal**: `neovim`, `zellij` multiplexer
      - **Language environments**: `pyenv`, `nvm`, `mise`

      ### Infrastructure & Containers
      - **Container tools**: `docker`, `kubectl`, `helm`
      - **Infrastructure**: `terraform`, `terragrunt`
      - **Utilities**: `jq`, `jc`, `tree`, `fzf`, `wget`, `htop`

      ### 600+ Productivity Aliases
      ```bash
      gs          # git status
      k           # kubectl
      tf          # terraform
      serve       # HTTP server in current directory
      ```

      Run `learn-aliases` after installation to explore all shortcuts.

      ## Security Features

      🔒 **Zero Telemetry**: No analytics, crash reporting, or usage tracking
      🔒 **No Auto-Updates**: Tools won't check for updates or phone home
      🔒 **Offline Capable**: All tools work without internet connection
      🔒 **User-Controlled Network**: Only you decide when tools connect externally

      ## Manual Installation

      For step-by-step setup, see `docs/10-homebrew.md`.

      ## Requirements

      - macOS 10.15+
      - Xcode Command Line Tools
      - Administrator access

      ## Maintenance

      ```bash
      brew update && brew upgrade && pipx upgrade-all
      ```

      ---

      Created by [Nikolay-E](https://github.com/nikolay-e) • [Issues](https://github.com/nikolay-e/mac-dev-setup/issues)
  - name: "docs"
    type: directory
    children:
    - name: "00-prereqs.md"
      type: file
      content: |
        # Prerequisites

        **TL;DR** - Run these three commands:
        ```bash
        xcode-select --install
        softwareupdate --install-rosetta --agree-to-license  # Apple Silicon only
        ssh-keygen -t ed25519 -C "your.email@example.com"
        ```

        ## 1. Xcode Command Line Tools

        Required for git, compilers, and other development tools.

        ```bash
        xcode-select --install
        ```

        A dialog will appear. Click "Install" and wait ~10 minutes.

        **Verify installation:**
        ```bash
        xcode-select -p
        # Should output: /Library/Developer/CommandLineTools
        ```

        ## 2. Rosetta 2 (Apple Silicon Macs only)

        Some tools still require Intel emulation on M1/M2/M3 Macs.

        ```bash
        # Check if you have Apple Silicon
        uname -m
        # If output is "arm64", run:
        softwareupdate --install-rosetta --agree-to-license
        ```

        ## 3. SSH Keys (Optional but Recommended)

        For GitHub/GitLab authentication without passwords.

        ```bash
        # Generate key (replace with your email)
        ssh-keygen -t ed25519 -C "your.email@example.com"

        # Start SSH agent
        eval "$(ssh-agent -s)"

        # Add key to agent
        ssh-add ~/.ssh/id_ed25519

        # Copy public key to clipboard
        pbcopy < ~/.ssh/id_ed25519.pub
        ```

        Then add to GitHub: Settings → SSH and GPG keys → New SSH key

        ## 4. Admin Access

        You'll need admin privileges for Homebrew installation. Test with:

        ```bash
        sudo -v
        # Enter your password when prompted
        ```

        ## Next Steps

        ✅ All prerequisites met? Continue to [10-homebrew.md](10-homebrew.md)
    - name: "10-homebrew.md"
      type: file
      content: |
        # Homebrew Installation & Package Setup

        **TL;DR** - Install Homebrew and all packages:
        ```bash
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        eval "$(/opt/homebrew/bin/brew shellenv)"  # Apple Silicon
        brew bundle --file=./Brewfile
        ```

        ## Why Homebrew?

        Homebrew manages packages without sudo, handles dependencies automatically, and works on both Intel and Apple Silicon.

        All tools are vetted for security and work offline without telemetry.

        ## Step 1: Install Homebrew

        ### Apple Silicon (M1/M2/M3) Macs:
        ```bash
        # Install Homebrew
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

        # Add Homebrew to PATH
        echo >> ~/.zprofile
        echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/opt/homebrew/bin/brew shellenv)"
        ```

        ### Intel Macs:
        ```bash
        # Install Homebrew
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

        # Add Homebrew to PATH (usually automatic on Intel)
        echo >> ~/.zprofile
        echo 'eval "$(/usr/local/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/usr/local/bin/brew shellenv)"
        ```

        ### Verify Installation:
        ```bash
        brew --version
        # Should output: Homebrew 4.x.x
        ```

        ## Step 2: Install Development Tools

        ### Option A: Use the automated script (Recommended)
        ```bash
        bash tasks/brew.install.sh
        ```

        ### Option B: Manual installation
        ```bash
        # Install all packages using Brewfile
        brew bundle --file=./Brewfile
        ```

        ### Option C: Individual packages
        ```bash
        # Core tools
        brew install git git-delta gh wget htop

        # Modern CLI replacements
        brew install bat eza fd ripgrep zoxide

        # ... etc (see Brewfile for full list)
        ```

        ## Step 3: Post-Installation Setup

        Some tools need additional configuration:

        ### 1. FZF (Fuzzy Finder)
        ```bash
        # Install shell integration
        $(brew --prefix)/opt/fzf/install --no-update-rc --key-bindings --completion
        ```

        ### 2. Node Version Manager
        ```bash
        # Create NVM directory
        mkdir -p ~/.nvm
        ```

        ## Common Issues

        ### "brew: command not found"
        You need to add Homebrew to your PATH. Re-run the eval command from Step 1.

        ### "Permission denied" errors
        Never use sudo with brew. If you see permission errors:
        ```bash
        sudo chown -R $(whoami) $(brew --prefix)/*
        ```

        ### Slow downloads
        Use a different Homebrew mirror:
        ```bash
        export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles
        ```

        ## Maintenance

        ```bash
        # Update package definitions
        brew update

        # Upgrade all packages
        brew upgrade

        # Clean old versions
        brew cleanup
        ```

        ## Next Steps

        ✅ Homebrew installed? Continue with `pipx install ./learn-aliases` to set up productivity aliases.
  - name: "install.sh"
    type: file
    content: |
      #!/usr/bin/env bash
      # mac-dev-setup installer - secure, vetted development environment
      set -euo pipefail

      # --- Helper Functions ---
      source "$(dirname "$0")/tasks/common.sh"

      # --- Main Script ---
      echo "🚀 mac-dev-setup Installer"
      echo "=========================="
      echo "This script will set up your development environment with verified, offline-capable tools."
      echo ""

      info "The following actions will be performed:"

      # List Homebrew packages
      echo "📦 Install Homebrew Packages:"
      while IFS= read -r line || [[ -n "$line" ]]; do
          if [[ "$line" =~ ^[[:space:]]*brew[[:space:]]+\"([^\"]+)\" ]]; then
              echo "    • ${BASH_REMATCH[1]}"
          fi
      done < Brewfile

      # List Pipx packages
      echo ""
      echo "🐍 Install Python CLI Tools:"
      while IFS= read -r package || [[ -n "$package" ]]; do
          [[ -n "$package" && "$package" != \#* ]] && echo "    • $package"
      done < pipx.txt

      # List other actions
      echo ""
      echo "⚙️  Additional Setup:"
      echo "    • Create symlinks for aliases and shell configuration"
      echo "    • Configure your shell (~/.zshrc) to load the environment"
      echo "    • Disable telemetry for all installed tools"
      echo ""

      # Confirm before proceeding
      read -p "Continue with installation? [y/N] " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
          echo "Installation cancelled."
          exit 0
      fi

      # --- Execute Installation Tasks ---
      info "Starting installation..."

      if ! bash "tasks/brew.install.sh"; then
          echo "❌ Error: Homebrew task failed." >&2
          exit 1
      fi

      if ! bash "tasks/python.install.sh"; then
          echo "❌ Error: Python task failed." >&2
          exit 1
      fi

      # Apply security hardening
      if ! bash "tasks/apply-security-settings.sh"; then
          echo "⚠️  Warning: Security hardening failed, but continuing..." >&2
      fi

      info "✅ Installation complete!"
      echo ""
      echo "🔒 Your environment is configured for security:"
      echo "   • No telemetry or analytics"
      echo "   • No automatic updates"
      echo "   • All tools work offline"
      echo ""
      echo "📋 Next steps:"
      echo "   1. Restart your terminal"
      echo "   2. Run 'learn-aliases' to explore available shortcuts"
      echo ""
  - name: "learn-aliases"
    type: directory
    children:
    - name: "README.md"
      type: file
      content: |
        # learn-aliases

        Interactive quiz tool to help memorize mac-dev-setup aliases.

        ## Installation

        ```bash
        pipx install git+https://github.com/nikolay-e/mac-dev-setup.git#subdirectory=learn-aliases
        ```

        ## Usage

        ```bash
        learn-aliases
        ```

        The tool will:
        - Load aliases from ~/.mac-dev-setup-aliases
        - Present descriptions as hints
        - Ask you to type the corresponding alias
        - Track your score

        Press Ctrl+C to quit at any time.
    - name: "learn_aliases"
      type: directory
      children:
      - name: "__init__.py"
        type: file
        content: |
          # learn_aliases package
      - name: "cli.py"
        type: file
        content: |
          #!/usr/bin/env python3
          """
          learn-aliases - Interactive quiz to master your mac-dev-setup shortcuts.

          Scans your ~/.mac-dev-setup-aliases file and presents an interactive quiz
          to help you learn and memorize aliases and functions with categories,
          progress tracking, and multiple quiz modes.
          """

          import os
          import random
          import re
          import readline  # noqa: F401  # history + arrow-key editing on most systems
          import argparse
          from typing import List, Dict, Set
          from dataclasses import dataclass
          from collections import defaultdict

          # Configuration
          ALIAS_FILE = os.path.expanduser("~/.mac-dev-setup-aliases")
          ALIAS_PATTERN = re.compile(r"^\s*alias\s+([\w.\-]+)='([^']+)'(?:\s*#\s*(.*))?")
          FUNCTION_PATTERN = re.compile(r"^([a-z][a-z_]*)\(\)\s*\{")
          COMMENT_PATTERN = re.compile(r"^##\s*(.+)")

          # ANSI color codes for better UI
          class Colors:
              GREEN = '\033[92m'
              RED = '\033[91m'
              BLUE = '\033[94m'
              YELLOW = '\033[93m'
              MAGENTA = '\033[95m'
              CYAN = '\033[96m'
              WHITE = '\033[97m'
              BOLD = '\033[1m'
              RESET = '\033[0m'

          @dataclass
          class Item:
              name: str
              command: str
              description: str
              category: str
              item_type: str  # 'alias' or 'function'

          def extract_category_from_comment(comment: str) -> str:
              """Extract category from section comments like '## Git' -> 'Git'"""
              if not comment:
                  return "Other"

              # Common category mappings
              category_map = {
                  "modern cli replacements": "CLI Tools",
                  "navigation": "Navigation",
                  "git": "Git",
                  "kubernetes": "Kubernetes",
                  "docker": "Docker",
                  "terraform": "Terraform",
                  "aws cli": "AWS",
                  "python": "Python",
                  "homebrew": "Homebrew",
                  "npm": "Node.js",
                  "productivity": "Productivity",
                  "utilities": "Utilities",
                  "kafka": "Kafka",
                  "neovim": "Editor"
              }

              comment_lower = comment.lower()
              for key, value in category_map.items():
                  if key in comment_lower:
                      return value

              return comment.title()

          def load_items(path: str) -> List[Item]:
              """Parse the alias file and return list of Items (aliases + functions)."""
              items: List[Item] = []
              current_category = "Other"

              if not os.path.exists(path):
                  print(f"{Colors.RED}Alias file not found: {path}{Colors.RESET}")
                  print("\nMake sure mac-dev-setup is installed and aliases are linked.")
                  return []

              try:
                  with open(path, "r", encoding="utf-8") as f:
                      lines = f.readlines()

                  i = 0
                  while i < len(lines):
                      line = lines[i].strip()

                      # Check for category comment
                      comment_match = COMMENT_PATTERN.match(line)
                      if comment_match:
                          current_category = extract_category_from_comment(comment_match.group(1))
                          i += 1
                          continue

                      # Check for alias
                      alias_match = ALIAS_PATTERN.match(line)
                      if alias_match:
                          alias, cmd, comment = alias_match.groups()
                          desc = (comment or cmd).strip()
                          items.append(Item(
                              name=alias,
                              command=cmd,
                              description=desc,
                              category=current_category,
                              item_type="alias"
                          ))
                          i += 1
                          continue

                      # Check for function
                      func_match = FUNCTION_PATTERN.match(line)
                      if func_match:
                          func_name = func_match.group(1)

                          # Look for function description in comments before or after
                          desc = f"Function: {func_name}"

                          # Check previous lines for comments
                          for j in range(max(0, i-3), i):
                              prev_line = lines[j].strip()
                              if prev_line.startswith('#') and not prev_line.startswith('##'):
                                  potential_desc = prev_line.lstrip('# ').strip()
                                  if len(potential_desc) > 5:  # Reasonable description length
                                      desc = potential_desc
                                      break

                          # Try to extract a simple description from the function body
                          if desc == f"Function: {func_name}":
                              for j in range(i+1, min(i+5, len(lines))):
                                  body_line = lines[j].strip()
                                  if body_line.startswith('echo ') and 'Usage:' in body_line:
                                      desc = body_line.replace('echo "', '').replace('"', '').replace('echo ', '')
                                      break
                                  elif body_line.startswith('#'):
                                      potential_desc = body_line.lstrip('# ').strip()
                                      if len(potential_desc) > 5:
                                          desc = potential_desc
                                          break

                          items.append(Item(
                              name=func_name,
                              command=f"{func_name}()",
                              description=desc,
                              category=current_category,
                              item_type="function"
                          ))
                          i += 1
                          continue

                      i += 1

              except Exception as e:
                  print(f"{Colors.RED}Error reading alias file: {e}{Colors.RESET}")
                  return []

              return items

          def display_stats(items: List[Item]):
              """Display statistics about available items."""
              by_category = defaultdict(list)
              by_type = defaultdict(int)

              for item in items:
                  by_category[item.category].append(item)
                  by_type[item.item_type] += 1

              print(f"\n{Colors.BOLD}{Colors.CYAN}📊 Available Items{Colors.RESET}")
              print("=" * 50)
              print(f"Total: {Colors.BOLD}{len(items)}{Colors.RESET} items")
              print(f"  • {Colors.GREEN}{by_type['alias']}{Colors.RESET} aliases")
              print(f"  • {Colors.BLUE}{by_type['function']}{Colors.RESET} functions")

              print(f"\n{Colors.BOLD}By Category:{Colors.RESET}")
              for category, category_items in sorted(by_category.items()):
                  aliases = sum(1 for item in category_items if item.item_type == 'alias')
                  functions = sum(1 for item in category_items if item.item_type == 'function')
                  print(f"  {Colors.YELLOW}{category:<15}{Colors.RESET} {aliases:>2} aliases, {functions:>2} functions")

          def quiz_all(items: List[Item]):
              """Run quiz on all items."""
              if not items:
                  print(f"{Colors.RED}No items found to quiz on.{Colors.RESET}")
                  return

              random.shuffle(items)
              run_quiz(items, "All Items")

          def quiz_by_category(items: List[Item]):
              """Let user choose a category to quiz on."""
              by_category = defaultdict(list)
              for item in items:
                  by_category[item.category].append(item)

              print(f"\n{Colors.BOLD}{Colors.CYAN}📚 Select Category{Colors.RESET}")
              print("=" * 30)
              categories = sorted(by_category.keys())

              for i, category in enumerate(categories, 1):
                  count = len(by_category[category])
                  print(f"{i:>2}. {Colors.YELLOW}{category:<15}{Colors.RESET} ({count} items)")

              try:
                  choice = input(f"\n{Colors.BOLD}Choose category (1-{len(categories)}): {Colors.RESET}").strip()
                  idx = int(choice) - 1
                  if 0 <= idx < len(categories):
                      selected_category = categories[idx]
                      category_items = by_category[selected_category]
                      random.shuffle(category_items)
                      run_quiz(category_items, f"{selected_category} Category")
                  else:
                      print(f"{Colors.RED}Invalid choice!{Colors.RESET}")
              except (ValueError, KeyboardInterrupt):
                  print(f"\n{Colors.YELLOW}Cancelled.{Colors.RESET}")

          def quiz_by_type(items: List[Item]):
              """Quiz by item type (aliases vs functions)."""
              print(f"\n{Colors.BOLD}{Colors.CYAN}🎯 Select Type{Colors.RESET}")
              print("=" * 25)
              print(f"1. {Colors.GREEN}Aliases only{Colors.RESET}")
              print(f"2. {Colors.BLUE}Functions only{Colors.RESET}")

              try:
                  choice = input(f"\n{Colors.BOLD}Choose type (1-2): {Colors.RESET}").strip()
                  if choice == "1":
                      alias_items = [item for item in items if item.item_type == 'alias']
                      random.shuffle(alias_items)
                      run_quiz(alias_items, "Aliases Only")
                  elif choice == "2":
                      func_items = [item for item in items if item.item_type == 'function']
                      random.shuffle(func_items)
                      run_quiz(func_items, "Functions Only")
                  else:
                      print(f"{Colors.RED}Invalid choice!{Colors.RESET}")
              except (ValueError, KeyboardInterrupt):
                  print(f"\n{Colors.YELLOW}Cancelled.{Colors.RESET}")

          def run_quiz(items: List[Item], quiz_name: str):
              """Run the interactive quiz."""
              score = 0
              total = len(items)

              print(f"\n{Colors.BOLD}{Colors.MAGENTA}🎓 {quiz_name} Quiz{Colors.RESET}")
              print("=" * (len(quiz_name) + 10))
              print(f"Total items: {Colors.BOLD}{total}{Colors.RESET}")
              print(f"{Colors.CYAN}Press Ctrl+C to quit at any time{Colors.RESET}\n")

              try:
                  for idx, item in enumerate(items, 1):
                      # Display item info
                      type_color = Colors.GREEN if item.item_type == 'alias' else Colors.BLUE
                      type_symbol = "📎" if item.item_type == 'alias' else "⚙️"

                      print(f"{Colors.BOLD}[{idx}/{total}]{Colors.RESET} "
                            f"{type_symbol} {Colors.YELLOW}{item.category}{Colors.RESET}")
                      print(f"   {item.description}")

                      answer = input(f"   {Colors.BOLD}Enter command: {Colors.RESET}").strip()

                      if answer == item.name:
                          print(f"   {Colors.GREEN}✅ Correct!{Colors.RESET}\n")
                          score += 1
                      else:
                          print(f"   {Colors.RED}❌ Incorrect{Colors.RESET}")
                          print(f"   {Colors.BOLD}Answer:{Colors.RESET} {Colors.CYAN}{item.name}{Colors.RESET}")
                          print(f"   {Colors.BOLD}Runs:{Colors.RESET} {item.command}\n")

              except KeyboardInterrupt:
                  print(f"\n\n{Colors.YELLOW}Quiz interrupted by user.{Colors.RESET}\n")

              # Show final score with colors
              percentage = (score / total * 100) if total > 0 else 0
              print(f"\n{Colors.BOLD}{Colors.CYAN}🏆 Final Score{Colors.RESET}")
              print("=" * 20)
              print(f"Score: {Colors.BOLD}{score}/{total}{Colors.RESET} ({percentage:.1f}%)")

              if score == total:
                  print(f"{Colors.GREEN}🎉 Perfect! You know all the {quiz_name.lower()}!{Colors.RESET}")
              elif percentage >= 80:
                  print(f"{Colors.GREEN}🌟 Excellent! You know most of the {quiz_name.lower()}.{Colors.RESET}")
              elif percentage >= 60:
                  print(f"{Colors.YELLOW}👍 Good progress! Keep practicing.{Colors.RESET}")
              elif percentage >= 40:
                  print(f"{Colors.YELLOW}📚 Getting there! These shortcuts will save you time.{Colors.RESET}")
              else:
                  print(f"{Colors.RED}📖 Keep practicing - these tools boost productivity!{Colors.RESET}")
              print()

          def show_main_menu(items: List[Item]):
              """Show interactive main menu."""
              while True:
                  print(f"\n{Colors.BOLD}{Colors.CYAN}🚀 Mac Dev Setup - Learn Shortcuts{Colors.RESET}")
                  print("=" * 40)
                  print(f"1. {Colors.GREEN}📊 Show Statistics{Colors.RESET}")
                  print(f"2. {Colors.MAGENTA}🎯 Quiz All Items{Colors.RESET}")
                  print(f"3. {Colors.YELLOW}📚 Quiz by Category{Colors.RESET}")
                  print(f"4. {Colors.BLUE}🎭 Quiz by Type{Colors.RESET}")
                  print(f"5. {Colors.RED}🚪 Exit{Colors.RESET}")

                  try:
                      choice = input(f"\n{Colors.BOLD}Choose option (1-5): {Colors.RESET}").strip()

                      if choice == "1":
                          display_stats(items)
                      elif choice == "2":
                          quiz_all(items)
                      elif choice == "3":
                          quiz_by_category(items)
                      elif choice == "4":
                          quiz_by_type(items)
                      elif choice == "5":
                          print(f"{Colors.CYAN}Happy coding! 🎉{Colors.RESET}")
                          break
                      else:
                          print(f"{Colors.RED}Invalid choice! Please enter 1-5.{Colors.RESET}")

                  except (KeyboardInterrupt, EOFError):
                      print(f"\n{Colors.CYAN}Goodbye! 👋{Colors.RESET}")
                      break

          def main():
              """Main entry point for the CLI."""
              parser = argparse.ArgumentParser(
                  description="Interactive quiz to master mac-dev-setup shortcuts",
                  formatter_class=argparse.RawDescriptionHelpFormatter,
                  epilog="""
          Examples:
            learn-aliases              # Interactive menu
            learn-aliases --stats      # Show statistics only
            learn-aliases --quick      # Quick quiz (all items)
                  """
              )
              parser.add_argument("--stats", action="store_true", help="Show statistics and exit")
              parser.add_argument("--quick", action="store_true", help="Start quick quiz immediately")
              parser.add_argument("--no-color", action="store_true", help="Disable colored output")

              args = parser.parse_args()

              if args.no_color:
                  # Disable all colors
                  for attr in dir(Colors):
                      if not attr.startswith('_'):
                          setattr(Colors, attr, '')

              items = load_items(ALIAS_FILE)
              if not items:
                  print(f"{Colors.RED}Please install mac-dev-setup first: https://github.com/nikolay-e/mac-dev-setup{Colors.RESET}")
                  return

              if args.stats:
                  display_stats(items)
              elif args.quick:
                  quiz_all(items)
              else:
                  show_main_menu(items)

          if __name__ == "__main__":
              main()
    - name: "setup.py"
      type: file
      content: |
        from setuptools import setup, find_packages

        setup(
            name="learn-aliases",
            version="1.0.0",
            description="Interactive quiz to learn mac-dev-setup aliases",
            author="mac-dev-setup",
            packages=find_packages(),
            entry_points={
                "console_scripts": [
                    "learn-aliases=learn_aliases.cli:main",
                ],
            },
            python_requires=">=3.8",
            classifiers=[
                "Programming Language :: Python :: 3",
                "License :: OSI Approved :: MIT License",
                "Operating System :: OS Independent",
            ],
        )
  - name: "package.json"
    type: file
    content: |
      {
        "name": "mac-dev-setup-plugins",
        "version": "1.0.0",
        "private": true,
        "description": "Manages Zsh plugins using NPM/Git for Dependabot compatibility.",
        "dependencies": {
          "zsh-autosuggestions": "git+https://github.com/zsh-users/zsh-autosuggestions.git#v0.7.1",
          "zsh-syntax-highlighting": "git+https://github.com/zsh-users/zsh-syntax-highlighting.git#0.8.0"
        },
        "devDependencies": {},
        "scripts": {
          "generate-plugins": "echo 'Run install.sh to generate plugins.toml from this package.json'"
        },
        "keywords": ["zsh", "shell", "plugins", "dotfiles", "mac", "development"],
        "author": "nikolay-e",
        "license": "MIT"
      }
  - name: "pipx.txt"
    type: file
    content: |
      # Vetted Python CLI tools for secure environments
      ./learn-aliases
  - name: "plugins.toml"
    type: file
    content: |
      # plugins.toml
      # This file is AUTO-GENERATED from package.json by install.sh
      # DO NOT EDIT MANUALLY - Edit package.json instead

      shell = "zsh"

      [plugins]

      # autosuggestions
      [plugins.zsh-autosuggestions]
      github = "zsh-users/zsh-autosuggestions"

      # syntax highlighting
      [plugins.zsh-syntax-highlighting]
      github = "zsh-users/zsh-syntax-highlighting"
  - name: "tasks"
    type: directory
    children:
    - name: "apply-security-settings.sh"
      type: file
      content: |
        #!/usr/bin/env bash
        # tasks/apply-security-settings.sh - Configure tools for secure, telemetry-free operation
        #
        # Usage:
        #   bash tasks/apply-security-settings.sh

        set -euo pipefail

        echo "🔒 Configuring tools for local profile (telemetry-free)..."

        # Disable Homebrew telemetry
        if command -v brew &>/dev/null; then
          echo "- Disabling Homebrew analytics..."
          brew analytics off 2>/dev/null || true
        fi

        # Disable git-delta update checks
        if command -v git &>/dev/null; then
          echo "- Disabling git-delta update checks..."
          git config --global delta.check-for-updates false 2>/dev/null || true
        fi

        # Note: lazygit removed from project

        # Set environment variables for current session
        export HOMEBREW_NO_ANALYTICS=1
        export HOMEBREW_NO_AUTO_UPDATE=1
        export HOMEBREW_NO_INSTALL_FROM_API=1
        export GIT_TERMINAL_PROMPT=0

        # Add to shell config if not already present
        SHELL_CONFIG=""
        if [[ -f ~/.zshrc ]]; then
          SHELL_CONFIG=~/.zshrc
        elif [[ -f ~/.bashrc ]]; then
          SHELL_CONFIG=~/.bashrc
        fi

        if [[ -n "$SHELL_CONFIG" ]]; then
          echo "- Adding telemetry-blocking environment variables to $SHELL_CONFIG..."

          # Check if already configured
          if ! grep -q "HOMEBREW_NO_ANALYTICS" "$SHELL_CONFIG" 2>/dev/null; then
            cat >> "$SHELL_CONFIG" <<'EOF'

        # Telemetry-free environment (added by mac-dev-setup)
        export HOMEBREW_NO_ANALYTICS=1
        export HOMEBREW_NO_AUTO_UPDATE=1
        export GIT_TERMINAL_PROMPT=0
        EOF
            echo "  Environment variables added to $SHELL_CONFIG"
          else
            echo "  Environment variables already configured"
          fi
        fi

        echo ""
        echo "✅ Local profile configuration complete!"
        echo ""
        echo "Your tools are now configured to:"
        echo "  - Never send telemetry"
        echo "  - Never auto-update"
        echo "  - Work completely offline"
        echo ""
        echo "Note: Restart your terminal for all changes to take effect."
    - name: "brew.install.sh"
      type: file
      content: |
        #!/usr/bin/env bash
        # tasks/brew.install.sh - install packages listed in Brewfile
        #
        # Usage:
        #   bash tasks/brew.install.sh           # Install all packages
        #   bash tasks/brew.install.sh --dry-run # Show what would be installed
        #   bash tasks/brew.install.sh --print   # Print raw commands for copy-paste

        set -euo pipefail

        # Environment variables for current session only
        export HOMEBREW_NO_ANALYTICS=1
        export HOMEBREW_NO_AUTO_UPDATE=1

        # Load common utilities
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        source "$SCRIPT_DIR/common.sh"

        # Parse arguments
        parse_common_args "$@" "Install Homebrew packages from Brewfile"

        # Find config file relative to script location
        CONFIG_FILE="$SCRIPT_DIR/../Brewfile"

        if [[ ! -f "$CONFIG_FILE" ]]; then
          echo "Error: Config file not found: $CONFIG_FILE"
          exit 1
        fi

        # Check if Homebrew is installed
        if ! command -v brew &>/dev/null && [[ $PRINT -eq 0 ]]; then
          echo "Error: Homebrew is not installed. See docs/10-homebrew.md"
          exit 1
        fi

        # Process each line in the Brewfile
        while IFS= read -r line || [[ -n "$line" ]]; do
          # Skip empty lines and comments
          [[ -z "$line" || "$line" == \#* ]] && continue

          # Extract package name from brew "package" format
          if [[ "$line" =~ ^[[:space:]]*brew[[:space:]]+\"([^\"]+)\" ]]; then
            formula="${BASH_REMATCH[1]}"
          else
            # Skip non-brew lines
            continue
          fi

          # Build command
          cmd="brew install $formula"

          # Use common run_cmd function with continue_on_error=true
          run_cmd "$cmd" true
        done < "$CONFIG_FILE"

        if [[ $PRINT -eq 0 ]] && [[ $DRY -eq 0 ]]; then
          echo "Homebrew packages installation complete!"
        fi
    - name: "common.sh"
      type: file
      content: |
        #!/usr/bin/env bash
        # tasks/common.sh - Common utilities for task scripts

        # Standardized argument parsing for task scripts
        parse_common_args() {
          DRY=0
          PRINT=0
          while [[ $# -gt 0 ]]; do
            case "$1" in
              -n|--dry-run) DRY=1 ;;
              --print) PRINT=1 ;;
              -h|--help)
                echo "$2"
                echo "Usage: $0 [--dry-run] [--print]"
                exit 0
                ;;
              *) echo "Unknown option: $1"; exit 1 ;;
            esac
            shift
          done
          export DRY PRINT
        }

        # Standardized command execution with consistent error handling
        run_cmd() {
          local cmd="$1"
          local continue_on_error="${2:-false}"

          if (( PRINT )); then
            echo "$cmd"
          elif (( DRY )); then
            echo "+ $cmd"
          else
            echo "Running: $cmd"
            if ! eval "$cmd"; then
              if [[ "$continue_on_error" == "true" ]]; then
                echo "Warning: Command failed but continuing: $cmd" >&2
                return 1
              else
                echo "Error: Command failed: $cmd" >&2
                exit 1
              fi
            fi
          fi
        }

        # Standardized info function
        info() {
          printf "\n\033[1;34m%s\033[0m\n" "$1"
        }

        # Standardized warning function
        warn() {
          printf "\n\033[1;33m%s\033[0m\n" "$1"
        }
    - name: "python.install.sh"
      type: file
      content: |
        #!/usr/bin/env bash
        # tasks/python.install.sh - setup Python environment with pyenv and pipx packages
        #
        # Usage:
        #   bash tasks/python.install.sh           # Install Python and packages
        #   bash tasks/python.install.sh --dry-run # Show what would be installed
        #   bash tasks/python.install.sh --print   # Print raw commands for copy-paste

        set -euo pipefail

        # Load common utilities
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        source "$SCRIPT_DIR/common.sh"

        # Parse arguments
        parse_common_args "$@" "Setup Python environment with pyenv and install pipx packages"

        # Find config file
        CONFIG_FILE="$SCRIPT_DIR/../pipx.txt"

        # Default Python version
        PYTHON_VERSION="${PYTHON_VERSION:-3.12}"

        # Step 1: Setup pyenv and install Python
        if (( PRINT )); then
          echo "# Setup pyenv"
          echo "export PYENV_ROOT=\"\$HOME/.pyenv\""
          echo "export PATH=\"\$PYENV_ROOT/bin:\$PATH\""
          echo "eval \"\$(pyenv init -)\""
          echo ""
          echo "# Find latest Python $PYTHON_VERSION"
          echo "LATEST_PYTHON=\$(pyenv install --list | grep -E \"^  ${PYTHON_VERSION}\\.[0-9]+\$\" | tail -1 | xargs)"
          echo "pyenv install \"\$LATEST_PYTHON\""
          echo "pyenv global \"\$LATEST_PYTHON\""
        elif [[ $DRY -eq 0 ]] && command -v pyenv &>/dev/null; then
          # Initialize pyenv
          export PYENV_ROOT="$HOME/.pyenv"
          export PATH="$PYENV_ROOT/bin:$PATH"
          eval "$(pyenv init -)"

          # Find latest patch version
          LATEST_VERSION=$(pyenv install --list | grep -E "^  ${PYTHON_VERSION}\.[0-9]+$" | tail -1 | xargs || echo "${PYTHON_VERSION}.0")

          if ! pyenv versions --bare | grep -q "^$LATEST_VERSION$"; then
            run_cmd "pyenv install $LATEST_VERSION"
          else
            echo "Python $LATEST_VERSION already installed"
          fi

          run_cmd "pyenv global $LATEST_VERSION"
        fi

        # Step 2: Ensure pipx is in PATH
        if (( PRINT )); then
          echo ""
          echo "# Add pipx to PATH"
          echo "export PATH=\"\$HOME/.local/bin:\$PATH\""
        else
          export PATH="$HOME/.local/bin:$PATH"
        fi

        # Step 3: Install pipx packages
        if [[ -f "$CONFIG_FILE" ]]; then
          if (( PRINT )); then
            echo ""
            echo "# Install pipx packages"
          fi

          while IFS= read -r package || [[ -n "$package" ]]; do
            # Skip empty lines and comments
            [[ -z "$package" || "$package" == \#* ]] && continue

            # Trim whitespace
            package="${package#"${package%%[![:space:]]*}"}"
            package="${package%"${package##*[![:space:]]}"}"

            if [[ "$package" == "./"* ]]; then
              # Local package - need full path
              local_path="$SCRIPT_DIR/../${package#./}"
              run_cmd "pipx install $local_path"
            else
              # Regular package
              run_cmd "pipx install $package"
            fi
          done < "$CONFIG_FILE"
        fi

        # Step 4: Setup shell integration
        if (( PRINT )); then
          echo ""
          echo "# Add to ~/.zshrc or ~/.bash_profile:"
          echo "export PYENV_ROOT=\"\$HOME/.pyenv\""
          echo "export PATH=\"\$PYENV_ROOT/bin:\$PATH\""
          echo "export PATH=\"\$HOME/.local/bin:\$PATH\""
          echo "eval \"\$(pyenv init -)\""
        elif [[ $DRY -eq 0 ]]; then
          echo ""
          echo "Python environment setup complete!"
          echo "Add these lines to your shell config if not already present:"
          echo '  export PYENV_ROOT="$HOME/.pyenv"'
          echo '  export PATH="$PYENV_ROOT/bin:$PATH"'
          echo '  export PATH="$HOME/.local/bin:$PATH"'
          echo '  eval "$(pyenv init -)"'
        fi
  - name: "test"
    type: directory
    children:
    - name: "scripts.bats"
      type: file
      content: |
        #!/usr/bin/env bats

        setup() {
          # Create temp directory for testing
          TEST_DIR=$(mktemp -d)
          export TEST_DIR
          export HOME="$TEST_DIR"
          cd "$BATS_TEST_DIRNAME/.." || exit
        }

        teardown() {
          # Clean up
          rm -rf "$TEST_DIR"
        }

        @test "zsh_config.sh exists and is readable" {
          [ -f "zsh_config.sh" ]
          [ -r "zsh_config.sh" ]
        }

        @test "Brewfile exists and has valid syntax" {
          [ -f "Brewfile" ]
          # Test Brewfile syntax
          ruby -c Brewfile
        }

        @test "alias file has required aliases" {
          [ -f ".mac-dev-setup-aliases" ]
          grep -q "alias ls=" .mac-dev-setup-aliases
          grep -q "alias v=" .mac-dev-setup-aliases
          grep -q "alias g=" .mac-dev-setup-aliases
        }

        @test "all shell scripts are executable" {
          [ -x "install.sh" ]
          [ -x "uninstall.sh" ]
        }

        @test "scripts use proper shebang" {
          head -1 install.sh | grep -Eq '#!/usr/bin/env bash|#!/bin/bash'
          head -1 uninstall.sh | grep -Eq '#!/usr/bin/env bash|#!/bin/bash'
        }

        @test "shell scripts have no syntax errors" {
          bash -n install.sh
          bash -n uninstall.sh
          bash -n tasks/brew.install.sh
          bash -n tasks/python.install.sh
          bash -n tasks/apply-security-settings.sh
          bash -n tasks/common.sh
        }

        @test "install.sh has required safety checks" {
          grep -q "set -euo pipefail" install.sh
          grep -q "command -v" install.sh
        }

        @test "destructive functions have safety prompts" {
          grep -q "gpristine()" .mac-dev-setup-aliases
          grep -q "Press Ctrl+C to cancel" .mac-dev-setup-aliases
        }

        @test "kafka functions check environment" {
          grep -q "KAFKA_BROKERS" .mac-dev-setup-aliases
          grep -q "Error: Set KAFKA_BROKERS" .mac-dev-setup-aliases
        }

        @test "config files exist" {
          [ -f "Brewfile" ]
          [ -f "pipx.txt" ]
        }

        @test "secure configuration includes vetted tools" {
          # Secure configuration should have core development tools
          grep -q '"git"' Brewfile
          grep -q '"neovim"' Brewfile
          grep -q '"docker"' Brewfile
          grep -q '"terraform"' Brewfile
          # Should NOT have unvetted network tools
          run ! grep -q '"gh"' Brewfile
          run ! grep -q '"trivy"' Brewfile
        }
  - name: "uninstall.sh"
    type: file
    content: |
      #!/bin/bash

      # Stop on first error, undefined variables, and pipe failures
      set -euo pipefail

      # --- Helper Functions ---
      source "$(dirname "$0")/tasks/common.sh"

      # --- Main Functions ---
      remove_shell_config() {
        info "Removing shell configuration..."
        local ZSHRC_SOURCE_LINE="source ~/.zsh_config.sh"
        local ZSHRC_COMMENT="# Load mac-dev-setup configuration"

        if grep -q "$ZSHRC_SOURCE_LINE" ~/.zshrc; then
          # Create backup before modifying
          cp ~/.zshrc ~/.zshrc.backup."$(date +%Y%m%d_%H%M%S)"

          # Remove the source line and comment (portable sed)
          if sed --version >/dev/null 2>&1; then
            # GNU sed (Linux)
            sed -i "/$ZSHRC_COMMENT/d" ~/.zshrc
            sed -i "/source ~\/.zsh_config.sh/d" ~/.zshrc
          else
            # BSD sed (macOS)
            sed -i '' "/$ZSHRC_COMMENT/d" ~/.zshrc
            sed -i '' "/source ~\/.zsh_config.sh/d" ~/.zshrc
          fi
          echo "Configuration removed from ~/.zshrc (backup created)"
        else
          echo "No configuration found in ~/.zshrc"
        fi
      }

      remove_symlinks() {
        info "Removing symlinks..."

        # Remove alias symlink
        if [ -h ~/.mac-dev-setup-aliases ]; then
          rm ~/.mac-dev-setup-aliases
          echo "Removed ~/.mac-dev-setup-aliases symlink"
        fi

        # Remove zsh_config symlink
        if [ -h ~/.zsh_config.sh ]; then
          rm ~/.zsh_config.sh
          echo "Removed ~/.zsh_config.sh symlink"
        fi

        # Remove Sheldon config symlink
        if [ -h ~/.config/sheldon/plugins.toml ]; then
          rm ~/.config/sheldon/plugins.toml
          echo "Removed Sheldon config symlink"
        fi

      }

      restore_backups() {
        info "Checking for backups to restore..."
        local backup_dir=~/.dotfiles_backup

        if [ -d "$backup_dir" ]; then
          echo "Found backup directory: $backup_dir"
          echo "You can manually restore files from this directory if needed."
        else
          echo "No backup directory found."
        fi
      }

      # --- Main Execution ---
      warn "This will remove mac-dev-setup configuration from your system."
      echo "Your installed tools (via Homebrew) will NOT be removed."
      echo -n "Continue? (y/N): "
      read -r response

      if [[ "$response" =~ ^[Yy]$ ]]; then
        info "Starting uninstall process..."
        remove_shell_config
        remove_symlinks
        restore_backups
        info "OK Uninstall complete! Restart your terminal to apply changes."
        printf "\nTo remove Homebrew packages, run: brew bundle cleanup --file=./Brewfile\n"
      else
        echo "Uninstall cancelled."
      fi
  - name: "zsh_config.sh"
    type: file
    content: |
      # shellcheck shell=bash
      # zsh_config.sh
      # This file is sourced by ~/.zshrc and managed by mac-dev-setup.

      # Environment Variables
      export PYENV_ROOT="$HOME/.pyenv"
      export PATH="$PYENV_ROOT/bin:$PATH"
      export PATH="$HOME/.local/bin:$PATH" # pipx tools
      export NVM_DIR="$HOME/.nvm"

      # Tool Initializations
      if command -v pyenv 1>/dev/null 2>&1; then eval "$(pyenv init -)"; fi
      # shellcheck disable=SC1091
      BREW_PREFIX=$(uname -m | grep -q arm64 && echo /opt/homebrew || echo /usr/local)
      # shellcheck disable=SC1091
      [ -s "$BREW_PREFIX/opt/nvm/nvm.sh" ] && \. "$BREW_PREFIX/opt/nvm/nvm.sh"
      # shellcheck disable=SC1090
      [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

      # Simple prompt
      export PS1='%1~ %# '
      if command -v sheldon 1>/dev/null 2>&1; then eval "$(sheldon source)"; fi
      if command -v zoxide 1>/dev/null 2>&1; then eval "$(zoxide init zsh)"; fi
      if command -v mise 1>/dev/null 2>&1; then eval "$(mise activate zsh)"; fi

      # Source Aliases
      # shellcheck disable=SC1090
      if [ -f ~/.mac-dev-setup-aliases ]; then source ~/.mac-dev-setup-aliases; fi

      # Source Personal Overrides (loaded last to override defaults)
      # shellcheck disable=SC1090
      if [ -f ~/.my_aliases ]; then source ~/.my_aliases; fi
